# Reverb, using FFTW if available and BQN-based FFT if not

Reverb â† {
  lwâ€¿lx â† (Â¯1âŠ‘â‰¢)Â¨ ğ•¨â€¿ğ•©
  ! 0<lw
  # Use the overlap-add method.
  o â† lw-1          # Overlap length
  k â† lx+o          # Result length
  n â† kâŒŠ(2â‹†14)âŒˆ3Ã—o  # Window length, including overlap
  n   âŒˆâŒ¾(2â‹†â¼âŠ¢)â†©     # Round up to power of two
  l â† n-o           # Without overlap
  k0â† âŒˆâŒ¾(Ã·âŸœl) k     # Rounded up
  ğ•¨ {
    CW â† (nâ†‘ğ•¨) _rev1
    {tâ†0 â‹„ kâ†‘â¥Š {râ€¿sâ†(-o)(tâŠ¸+âŒ¾(oâŠ¸â†‘)âˆ˜â†“â‹ˆâ†‘)CWğ•©â‹„tâ†©sâ‹„r}Ë˜ âˆ˜â€¿lâ¥Šk0â†‘ğ•©}â‰1 ğ•©
  }â‰(1â‰1+0âŒˆ-Ëœâ—‹=) ğ•©
}

# Convolve ğ•— and ğ•—â‰ âŠ¸â†‘ğ•©, assuming length of ğ•— is a power of 2
rev1 â† {ğ•Š
  # Use the half-complex form of FFTW
  # Converts e.g. 8 reals to r0,r1,r2,r3,r4,i3,i2,i1 and back
  pl â† ">" âˆ¾ plan â† "*:i32"
  Fn â† "/usr/lib/libfftw3.so.3"âŠ¸â€¢FFI
  createPlan  â† Fn planâ€¿"fftw_plan_r2r_1d"â€¿"i32"â€¿"*f64"â€¿"&f64"â€¿"i32"â€¿"i32"
  destroyPlan â† Fn ""â€¿"fftw_destroy_plan"â€¿pl
  executePlan â† Fn ""â€¿"fftw_execute"â€¿pl
  FFTR â† { ğ•Šâ¼ğ•©: 1ğ•Šğ•© ;
    planâ€¿out â† CreatePlan âŸ¨â‰ ğ•©,ğ•©,0Â¨ğ•©,ğ•¨âŠ£0,2â‹†6âŸ©
    ExecutePlan plan
    DestroyPlan plan
    out
  }
  {
    mhâ†-nhâ†1-Ëœ2Ã·Ëœnâ†â‰ ğ•—
    M â† (mh(â†“-0âˆ¾0âˆ¾ËœâŒ½âˆ˜â†‘)Ã—) âˆ¾ nh(âŒ½âˆ˜â†‘+-âŠ¸â†‘)Ã—âŸœâŒ½â—‹(1âŠ¸â†“)  # Scrambled complex Ã—
    (n Ã·Ëœ FFTR ğ•—)âŠ¸MâŒ¾FFTR nâŠ¸â†‘
  }
}âŠ{ğ•Š
  fft â† â€¢Import "fft.bqn"
  M â† -Ëâˆ˜Ã— â‰ +Ëâˆ˜Ã—âŸœâŒ½  # Complex multiplication
  {âŠ Â· (FFT ğ•—)âŠ¸MâŒ¾FFT (â‰ ğ•—)âŠ¸â†‘}
}@

Reverb
