# Stereo panning

o â† â‰ â—¶âŸ¨â€¢Importâˆ˜"options.bqn", âŠ‘âŸ© â€¢args
mixâ€¿fil â† â€¢ImportÂ¨ "mix.bqn"â€¿"filter.bqn"
âŸ¨CosâŸ© â† â€¢math

# The goal of stereo panning is to make sounds appear to come from
# different directions. A well-panned sound for music will have the
# following three features:
#
# 1. The high frequencies (and preferably only the high frequencies) are
#    louder on the near side.
# 2. The low frequencies begin slightly earlier on the near side.
# 3. It still sounds good when the channels are combined.
#
# Requirements 1 and 2 come from physics: these are properties acquired by
# sounds as they travel around a human head, and they are the features the
# brain uses to identify their source. Requirement 3 comes from the fact
# that music is sometimes played in mono and should still have acceptable
# quality when mixed this way.
#
# Requirement 1 causes no problems and is simple to implement by moving part
# of the far channel to the near side (that is, subtracting a fraction of
# that channel, possibly with a high-pass filter, from the far side and
# adding it to the near side). Requirements 2 and 3, however, are in direct
# conflict. The obvious solution to 2 is to delay the far channel; however
# doing so will cause comb filtering when channels are re-combined.
#
# Typically the answer is to drop one of the requirements. Acceptable stereo
# localization can still be obtained without any delays, thus dropping
# requirement 2. And panning with a delay, or more generally applying a
# head-related transfer function (HRTF), yields the best possible
# localization at the expense of a weak mono mix.
#
# However, it is possible to compromise, obtaining excellent (but not
# perfect) stereo and good mono. The key is to realize that only the lower
# frequencies must be delayed, a feat which can be performed with all-pass
# filters. For delays under 1/2000 of a second we can combine a forwards
# filter with a backwards filter to delay a wide range of frequencies and then
# undelay those over 2000Hz, since those frequencies are not used to detect
# delay. This leaves a signal largely without artifacts--the only issue is
# a small amount of attenuation at frequencies near the cutoff when the two
# channels are combined.

# Pan with all-pass filters. Arguments are the same as pan
# Delays the input by slightly more than 60 samples.
PanIR â† {
  AP â† fil.AllPass
  near â† 0.5>ğ•¨
  off â† | 1-Ëœ2Ã—ğ•¨
  ğ•© â†© (-âŠ¸â‰ off Ã— 5000 fil.Lp1 âŠ)âŠ¸+ ğ•©
  aâ€¿b â† Get_panap_coeff Shift_coeff offÃ—25
  near âŒ½ (bâŠ¸APâŒ¾âŒ½ aâŠ¸AP)âŒ¾âŠ ğ•©
}
Window â† (2Ã·Ëœ1+Cos Ï€Ã—1â†“â†•âŠ¸Ã·6)âŠ¸(âŠ£ âŒ½âŠ¸mix.Fadefront mix.Fadeback)  # Tukey window
PanAP â‡ Windowâˆ˜PanIRâŸ(â‰ âŸœ0.5)âŸœ(â‰Ëœ60=â†•180)âŠ¸mix.Reverb

# Empirically determined good coefficients for Panap
# y is a single parameter giving the delay for low frequencies.
Shift_coeff â† {
  f â† 732 + 79000 Ã· 1.6 â‹†Ëœ 10 + ğ•©
  rs â† 1.097â€¿Â¯2.054â€¿2.16 {+âŸœ(ğ•©âŠ¸Ã—)Â´ğ•¨} 1e4 Ã·Ëœ f
  ğ•©â€¿rsâ€¿f
}

# Data for Shift_coeff
# Values of rs which make the third derivative of the phase transfer at
# zero equal to zero. (rs Ã— 1000) is given.
#     frequency of max phase difference
#       2000 1750 1500 1250 1100 1000
# s  5   782  804  827  852  868  878
# h 10   816  829  845  864  876  885
# i 15   849  857  866  878  887  894
# f 20   875  879  885  893  899  904
# t 25   895  897  901  906  910  913
#
# "Good" shift, frequency, and rs values.
# Frequency is determined from the formula in Shift_coeff.
# In Shift_coeff, rs is modelled as quadratic w.r.t frequency.
# Ëœ0    2716  0.698
#  0.1  2685  0.701
#  1    2436  0.725
#  2.5  2121  0.759
#  5    1769  0.802
# 10    1387  0.853
# 15    1190  0.882
# 20    1074  0.900
# 25    1000  0.913
# 30     948  0.924

# =========================================================
# Argument is âŸ¨number of samples to shift, magnitude, stop frequencyâŸ©.
# Magnitude should be a real number strictly between 0 and 1,
# and controls how pointy the end result is in phase space.
# Returns two all-pass filter inputs matching the specifications.
#
# The polynomials here should probably be treated as black magic, but
# a derivation from the constraints is included below anyway.
Get_panap_coeff â† { ğ•Š nâ€¿rrâ€¿f:
  PM â† +Â´Â¨+âŒœâ—‹â†•â—‹â‰ âŠ”â—‹â¥ŠÃ—âŒœ  # Multiply polynomials

  r â† Ã—Ëœrr
  c1â€¿c2 â† 2Ã—CosÂ¨ 1â€¿2 Ã— 2Ã—Ï€Ã—fÃ·o.freq

  q â† (r-1)Ã—2Ã·n
  poly â† +Â´ âŸ¨
    4Ã—âŸ¨1+r+q,Â¯2âŸ© PM (âŸ¨r,1+r,0âŸ©Ã—âŸ¨0,6,0âŸ©+c2-2Ã—c1) + âŸ¨1+Ã—Ëœr,0,4âŸ©Ã—1-c1
    âŸ¨1+r,Â¯2âŸ© PMËœâŠ¸PM (2+c1)Ã—âŸ¨1+r,-c1âŸ©
  âŸ©

  P â† {+âŸœ(ğ•©âŠ¸Ã—)Â´poly}
  v â† PÂ¨ bndâ†0â€¿rr
  ! 0â‰¥Ã—Â´v
  s â† -Ã—âŠ‘v
  re â† âŠ‘ (sÃ—v) {uâ†sÃ—P mâ†2Ã·Ëœ+Â´ğ•©â‹„ğ•ŠâŸ(1eÂ¯15<-ËœÂ´âˆ˜âŠ¢)Â´uâ€¿m((0â‰¤u)âŠ‘âŒˆâ€¿âŒŠ)Â¨ğ•¨â€¿ğ•©} bnd

  sv â† (Ã—Ëœ  Ã·  (4Ã—q) + Ã—âŸœ((3-r)+2Ã—re)) 1+r-2Ã—re

  GetZ â† âŠ¢ â‹ˆ âˆšâˆ˜-âŸœ(Ã—Ëœ)  # ğ•© is real part and ğ•¨ is square magnitude
  (GetZâ—‹âŠ‘ â‹ˆ GetZâ—‹(âŠ‘+svÃ—+Â´))Â´ âŸ¨râ€¿Â¯1,reâ€¿1âŸ©
}

# ---------------------------------------------------------
" # Derivation
# Transfer function for an all-pass filter: argument is z,
# and rs and re are (Ã—Ëœâˆ˜|) and (9&o.) of the complex parameter
H   = (1 + (rsÃ—Ã—Ëœ) - 2Ã—re&Ã—) Ã· (Ã—Ëœ + rs - 2Ã—re&Ã—)
# Derivative with respect to z
Hp  = (2 Ã— (re-Ëœrs&Ã—) - HÃ—(1-re)) Ã· (Ã—Ëœ+rs-2Ã—re&Ã—)
    = (2 Ã— (Ã— rs-H) - reÃ—1-ËœH) Ã· (Ã—Ëœ+rs-2Ã—re&Ã—)

# Definition of the phase transfer function T
(â‹†â³T Ï‰) = (H â‹†â³Ï‰)
# Derivative in terms of H and its derivative Hp
â³(â‹†â³T(Ï‰))Ã—Tp(Ï‰) = Hp(â‹†â³Ï‰)Ã—â³â‹†â³Ï‰
Tp(Ï‰) = Hp(â‹†â³Ï‰) Ã— â‹†â³Ï‰-T(Ï‰)
      = Hp(z) Ã— z Ã· H(z)
      = (2Ã—z Ã— (zÃ—rs-H) - reÃ—H-1) Ã· (1 + (rsÃ—Ã—Ëœs) - 2Ã—reÃ—z)

# Simplified at 1 and Â¯1 (0 and maximum frequency)
H(1)  = 1
T(0)  = 0
Tp(0) = (2Ã—rs-1) Ã· (1+rs-2Ã—re)

H(Â¯1) = 1
T(Ï€)  = 0
Tp(Ï€) = (2Ã—rs-1) Ã· (1+rs+2Ã—re)


# For a delay
H(z) = zâ‹†-n
T(Ï‰) = -nÃ—Ï‰
Tp(Ï‰) = -n

# Constraints
# We refer to the forward and backwards filters with
# postfixes of 1 and 2.
Tp1(0)  =  Tp2(0) - n
Tp1(Ï€)  â‰ƒ  Tp2(Ï€)
Tp1(f)  =  Tp2(f)

# In a symmetric notation: [a,b] = (a1Ã·b1) - (a2Ã·b2)
# where an and bn are the values for the nth filter.
# z2 = Ã—Ëœz
(-nÃ·2)= [rs-1 , 1+rs-2Ã—re]
0    =  [rs-1 , 1+rs+2Ã—re]
0    =  [((zÃ—rs-H) - reÃ—H-1) , (1 + (z2Ã—rs) - (2Ã—zÃ—re))]

# Useful identity
# Define (reC = re2 - re1) and (rsC = rs2 - rs1)
rs1Ã—re2 - rs2Ã—re1  =  (rs1Ã—re1 + rs1Ã—reC) - (rs1Ã—re1 + rsCÃ—re1)
                   =  rs1Ã—reC - rsCÃ—re1

# Second constraint, where [12] indicates the value with 1 and 2 swapped
((rs1-1) Ã— 1+rs2+2Ã—re2) = [12]
((rs1 Ã— 1+2Ã—re2) - (rs2+2Ã—re2)) = [12]
(rs1 + re1 + rs1Ã—re2) = [12]
0  =  rsC + reC + (re1Ã—rsC - reCÃ—rs1)
   =  (rsC Ã— re1+1) - (reC Ã— rs1-1)
(reC Ã· re1+1) = (rsC Ã· rs1-1)

# Thus, we can define s so that
reC = sÃ—re1+1
rsC = sÃ—rs1-1

rs1Ã—re2 - rs2Ã—re1  =  rs1Ã—reC - rsCÃ—re1
                   =  s Ã— (rs1Ã—re1+1) - (re1Ã—rs1-1)
                   =  s Ã— rs1 + re1

# Cross-multiply first constraint and subtract second
(rs2-rs1) = (nÃ·8)Ã—(1+rs1-2Ã—re1)Ã—(1+rs2-2Ã—re2)
(sÃ—rs1-1) = (nÃ·8)Ã—(1+rs1-2Ã—re1)Ã—((1+rs1-2Ã—re1) + sÃ—(rs1-1)-2Ã—(re1+1))
(s Ã— (rs1-1)Ã—(8Ã·n)) = (Ã—Ëœ 1+rs1-2Ã—re1) - sÃ—(1+rs1-2Ã—re1)Ã—(rs1-Ëœ3+2Ã—re1)
s  =  (Ã—Ëœ 1+rs1-2Ã—re1) Ã· (((rs1-1)Ã—(8Ã·n)) + (1+rs1-2Ã—re1)Ã—(rs1-Ëœ3+2Ã—re1))


# Third constraint
# Value of Tp, dropping factor of 2Ã—z
((zÃ—rs1-h1) + re1Ã—h1-1) Ã— (1 + (z2Ã—rs2) - (2Ã—zÃ—re2))  =  [12]
(re1 -Ëœ zÃ—rs1 + h1Ã—re1-z) Ã— (1 + (z2Ã—rs2) - (2Ã—zÃ—re2))  =  [12]
((zÃ—rs1) - (re1 + z2Ã—rs1Ã—re2)) + (h1Ã—re1-z)Ã—(1 + (z2Ã—rs2) - (2Ã—zÃ—re2))  =  [12]
((zÃ—rs1) - (re1 + z2Ã—rs1Ã—re2)) + (h1Ã—h2Ã—re1-z)Ã—(rs2 + z2 - 2Ã—zÃ—re2)  =  [12]
((zÃ—rs1) + (z2Ã—rs2Ã—re1) - re1) + h1Ã—h2Ã—((rs2Ã—re1) + (zÃ—rs1) - z2Ã—re1)  =  [12]
((zÃ—rsC) + (z2Ã—(rs1Ã—re2 - rs2Ã—re1)) - reC) + h1Ã—h2Ã—((rs1Ã—re2 - rs2Ã—re1) + (zÃ—rsC) - z2Ã—reC)  =  0
# Divide by s
((zÃ—rs1-1) + (z2Ã—(rs1+re1)) - re1+1) + h1Ã—h2Ã—((rs1+re1) + (zÃ—rs1-1) - z2Ã—re1+1)  =  0
((rs1Ã—z2+z) + (re1Ã—z2-1) - z+1) + h1Ã—h2Ã—((rs1Ã—z+1) + (re1Ã—1-z2) - z2+z)  =  0
# Divide by z+1
((rs1Ã—z) + (re1Ã—z-1) - 1) + h1Ã—h2Ã—(rs1 + (re1Ã—1-z) - z)  =  0
h1Ã—h2  =  ((rs1Ã—z) + (re1Ã—z-1) - 1) Ã· ((-rs1) + (re1Ã—z-1) + z)
       =  1  +  (z+1)Ã—(1-rs1) Ã· (rs1 + (re1Ã—1-z) - z)

# Value of h2 in terms of re1 and rs1
# With these and the previous definition, we obtain a 4th-order
# polynomial in re1 and rs1.
a = 2Ã—zÃ—re1,  r = rs1
h1 = ((1 + (z2Ã—r) - a)                             )  Ã·  ((z2 + r - a)                        )
h2 = ((1 + (z2Ã—r) - a) + sÃ—(((z2Ã—r) - a) - (zÃ—z+2)))  Ã·  ((z2 + r - a) + sÃ—((r - a) - (1+2Ã—z)))

# Algebra
h2 = 1  +  ((r-1)Ã—(z2-1)Ã—(1+s)) Ã· ((-aÃ—1+s) + (z2 + r) + sÃ—(r - (1+2Ã—z)))
   = 1  +  (r-1)Ã—(z2-1) Ã· (((Ã—Ëœ1+z)Ã·1+s) + (r - (1+2Ã—z)) - a)
   = 1  +  (r-1)Ã—(z2-1) Ã· ((z2+r-a) - (Ã—Ëœ1+z)Ã—sÃ·1+s)
h1 = 1  +  (r-1)Ã—(z2-1) Ã·  (z2+r-a)
sÃ·1+s  =  (Ã—Ëœ1+r-2Ã—e) Ã· (4 Ã— ((r-1)Ã—(2Ã·n)) + 1+r-2Ã—e)
       =  (Ã—Ëœ1+r-2Ã—e) Ã· (4 Ã— q + 1+r-2Ã—e)

# Put each of our values in a regular form, defining k, a=b+d, b, c
h2    = (1+kÃ·a) = 1  +  (1-r)Ã—(1-z2) Ã· ((z2+r-2Ã—zÃ—e) - (Ã—Ëœ1+z)Ã—sÃ·1+s)
h1    = (1+kÃ·b) = 1  +  (1-r)Ã—(1-z2) Ã·  (z2+r-2Ã—zÃ—e)
h1Ã—h2 = (1+kÃ·c) = 1  +  (1-r)Ã—(1-z2) Ã· (1-z)Ã—((r-z) + (1-z)Ã—e)

# Simplify the overall form
(1+kÃ·a)Ã—(1+kÃ·b) = (1+kÃ·c)
cÃ—(a+k)Ã—(b+k) = abÃ—(c+k)     # Cross-multiply
cÃ—(a+b+k) = ab               # Subtract abc
cÃ—k+b = aÃ—b-c

cÃ—k+b = (1-z)Ã—((r-z)+(1-z)Ã—e) Ã— ((1-r)Ã—(1-z2))+z2+r-2Ã—zÃ—e
      = (1-z)Ã—((r-z)+(1-z)Ã—e) Ã— (1+z2Ã—r)-2Ã—zÃ—e
aÃ—b-c = ((z2+r-2Ã—zÃ—e) - (Ã—Ëœ1+z)Ã—sÃ·1+s)Ã—((z2+r-2Ã—zÃ—e)-(1-z)Ã—((r-z) + (1-z)Ã—e))
      = ((z2+r-2Ã—zÃ—e) - (Ã—Ëœ1+z)Ã—sÃ·1+s)Ã—((zÃ—1+r) - eÃ—1+z2)

qâ†(r-1)Ã—(2Ã·n)
((1-z)Ã—âŸ¨r-z,1-zâŸ©PMâŸ¨1+z2Ã—r,-2Ã—zâŸ©PMâŸ¨4Ã—q+1+r,Â¯8âŸ©) + âŸ¨zÃ—1+r,-1+z2âŸ© PM (PMËœ(1+z)Ã—âŸ¨1+r,Â¯2âŸ©) - âŸ¨z2+r,-2Ã—zâŸ©PMâŸ¨4Ã—q+1+r,Â¯8âŸ©
# Group q
{(4Ã—âŸ¨q+1+r,Â¯2âŸ©PM(ğ•©PMâŸ¨z2+r,-2Ã—zâŸ©)-Ëœ(1-z)Ã—âŸ¨r-z,1-zâŸ©PMâŸ¨1+z2Ã—r,-2Ã—zâŸ©) + ğ•© PM PMËœ(1+z)Ã—âŸ¨1+r,Â¯2âŸ©}âŸ¨zÃ—1+r,-1+z2âŸ©

# Expand; divide by z2; simplify
zdâ†z+Ã·z â‹„ zeâ†z2+Ã·z2
(4Ã—âŸ¨q+1+r,Â¯2âŸ©PM(âŸ¨r,1+r,0âŸ©Ã—âŸ¨0,6,0âŸ©+ze-2Ã—zd)+âŸ¨1+Ã—Ëœr,0,4âŸ©Ã—1-zd) + (PMËœâŸ¨1+r,Â¯2âŸ©)PM(2+zd)Ã—âŸ¨1+r,-zdâŸ©"
