"mix.bqn takes a single option namespace, or no arguments" ! 1â‰¥â‰ â€¢args
o â† â‰ â—¶âŸ¨â€¢Importâˆ˜"options.bqn", âŠ‘âŸ© â€¢args
fft â† â€¢Import "fft.bqn"

# List of length |ğ•© that starts at 0 and stops just before 1,
# reversed if ğ•©<0.
I â‡ <âŸœ0 âŒ½âˆ˜âŠ¢âŸâŠ£ â†•âˆ˜|âŠ¸Ã·

# Add two signals ğ•¨ and ğ•© or a list of signals ğ•©,
# extending to the length of the longest signal.
Add â‡ +Â´ Â·(âŒˆÂ´(Â¯1âŠ‘â‰¢)Â¨)âŠ¸(â†‘â‰1Â¨) âŠ¢âŠ˜(â‰â—‹<)
# Like add, but concatenate instead.
Concat â‡ (âˆ¾ â†“Â¨ËœâŸœ(<0â¥ŠËœÂ·âŒˆÂ´=Â¨)) âŠ˜ (âˆ¾â‰1)
# Like âŒ½â‰1, but the end of the signal does not wrap around.
Shift â‡ <âŸœ0â—¶âŸ¨â†“â‰1 , (-â¥Š0Ë™)âŠ¸(âˆ¾â‰1)âŸ©
# Repeat signal ğ•© ğ•¨ times.
Rep â‡ (â¥Š/âŸœâ‰)â‰1
# ğ•¨ is locationâ€¿length. Obtain that part of signal ğ•©.
Slice â‡ (SliceI â† +âŸœ(0âŠ¸âŒŠ+â†•âˆ˜|)Â´)âˆ˜âŠ£ âŠâ‰1 âŠ¢
# Apply ğ”½ to the slice of ğ•© given by ğ•¨.
_onSlice â‡ { ğ”½âŒ¾((SliceIğ•¨)âŠâ‰1âŠ¢) ğ•© }

# Convert possibly-mono signal to stereo
Stereo â‡ â‰ËœâŸ(2>=)
# Pan signal ğ•© to position ğ•¨, where 0 is hard left and 1 is hard right
Pan â‡ (25âŒŠâˆ˜Ã—â‰âŸœÂ¬âˆ˜âŠ£) â¥ŠâŸœ0âŠ¸Â»Ë˜ ((=âŒœËœâ†•2)-Â·(Ã—Ã—âŒœ0âŠ¸âŒˆ)Â·â‰âŸœ-1-Ëœ2Ã—âŠ£)âŠ¸(+Ëâˆ˜Ã—â‰Â¯1â€¿âˆ)âŸœStereo

# Clipping functions clip to [Â¯1,1] by default
# _norm changes this to match the format if it's an integer format
_norm â‡ { (ğ•¨ğ”½âŠ¢)âŒ¾(Ã·âŸœ(2â‹†1-ËœÂ¯1âŠ‘o.fmt)) ğ•© }
# Clip signal ğ•© to the maximum possible range.
Clip â‡ 1âŒŠÂ¯1âŒˆâŠ¢
# ğ•¨ is an integer giving "sharpness". Perform a soft clip.
Softclip â‡ { Ã·âŸœ(1âŠ¸+âŒ¾(â‹†âŸœ(2â‹†ğ•¨âŠ£3))) ğ•© }

# Multiply leading or trailing samples of ğ•© by ğ•¨.
Fadefrontâ€¿Fadeback â‡ {ğ•Šf: {ğ•¨âŠ¸Ã—âŒ¾((Fâ‰ ğ•¨)â†‘âŠ¢)ğ•©}â‰1 }Â¨ âŠ¢â€¿-

# ğ•— is the overlap amount. Fade ğ•¨ into ğ•©, linearly.
_crossfade â‡ {
  Gâ†â†‘â‰â—‹<â†“
  (-ğ•—)âŠ¸GâŠ¸(âˆ¾ 1âŒ½âˆ¾Ëœâ—‹(1âŠ¸â†“) âˆ¾âŸœ< (Â¬âŠ¸â‰Iğ•—)+Ëâˆ˜Ã—â‰â—‹âŠ‘)âŸœ(ğ•—âŠ¸G)â‰1
}

# Apply reverb impulse response (IR) ğ•¨ to ğ•©.
# Argument rows are extended, giving result length (ğ•©+â—‹â‰ ğ•¨)-1 (for lists).
# Equivalent to (+Â´Â¨+âŒœâ—‹â†•â—‹â‰ âŠ”Ã—âŒœ)â‰1 except for numeric precision.
Reverb â‡ {
  M â† -Ëâˆ˜Ã— â‰ +Ëâˆ˜Ã—âŸœâŒ½ # Complex multiplication
  lwâ€¿lx â† (Â¯1âŠ‘â‰¢)Â¨ ğ•¨â€¿ğ•©
  ! 0<lw
  # Use the overlap-add method.
  o â† lw-1          # Overlap length
  n â† âŒˆâŒ¾(2â‹†â¼âŠ¢) 3Ã—o  # Window length, including overlap
  l â† n-o           # Without overlap
  k â† lx+o          # Result length
  k0â† âŒˆâŒ¾(Ã·âŸœl) k     # Rounded up
  ğ•¨ {
    CW â† âŠ Â· (FFT nâ†‘ğ•¨)âŠ¸MâŒ¾FFT nâŠ¸â†‘
    {tâ†0 â‹„ kâ†‘â¥Š {râ€¿sâ†(-o)(tâŠ¸+âŒ¾(oâŠ¸â†‘)âˆ˜â†“â‰â—‹<â†‘)CWğ•©â‹„tâ†©sâ‹„r}Ë˜ âˆ˜â€¿lâ¥Šk0â†‘ğ•©}â‰1 ğ•©
  }â‰(1â‰1+0âŒˆ-Ëœâ—‹=) ğ•©
}
