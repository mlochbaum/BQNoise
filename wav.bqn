# Functions to read to and write from wave files.
# Does not support many kinds of wave files, such as compressed data.

âŸ¨ReadWav, WriteWav, ReadWav_set, ReadWav_coerceâŸ©â‡

o â† options â‡ {
  FBytes â‡ â€¢FBytes
  fmt  â‡ 1â€¿16      # Format: 16-bit integer
  freq â‡ 44100     # Frequency: 44.1kHz
  warn_dither â‡ 0  # Whether to warn on non-integer signal
  warn_clip   â‡ 1  # Whether to warn on out-of-bounds signal
  Dither â‡ âŒŠ (0.5 + 0 -Ëâˆ˜(â€¢RANDâˆ˜â¥Š)Ëœ (2âˆ¾â‰¢))âŠ¸+
  Resample â‡ "No resampling function specified"!0Ë™
  Set â‡ {fmtâ€¿freqâ†©ğ•©}
}

# The output from ReadWav, or input to WriteWav, is either:
# - A list of:
#     The sample rate (in Hz)
#     The PCM format (see below)
#     PCM data, which has shape nâ€¿l for n channels with l samples.
# - The PCM data only
#   (options.freq and options.fmt are used for rate and format)
# 
# ReadWav returns the plain PCM data if the settings matched the
# options while ReadWav_set and ReadWav_coerce always return the
# plain data.

# A PCM format consists of the type of audio and the bit depth.
# The type is one of:
#   1  unsigned integer
#   3  floating point
# Other audio formats may be supported in the future.

# Wave file header format
wh â† {
  # Field properties are:
  #   len:  Length of field in bytes
  #   typ:  Whether to leave as chars (c) or convert to an integer (i)
  #   err:  Behavior on invalid value: fail (e), warn (w), or ignore (.)
  #         (Fields with ? depend on context)
  #   name: Field name
  #   def:  How to compute value
  lenâ€¿typâ€¿errâ€¿nameâ€¿def â‡ <Ë˜â‰>âŸ¨
    4â€¿'c'â€¿'e'â€¿"chunkID"      â€¿âŸ¨"RIFF"âŸ©
    4â€¿'i'â€¿'w'â€¿"chunkSize"    â€¿âŸ¨20++Â´,"subchunk1Size","subchunk2Size"âŸ©
    4â€¿'c'â€¿'e'â€¿"format"       â€¿âŸ¨"WAVE"âŸ©
    4â€¿'c'â€¿'e'â€¿"subchunk1ID"  â€¿âŸ¨"fmt "âŸ©
    4â€¿'i'â€¿'?'â€¿"subchunk1Size"â€¿âŸ¨16âŸ©
    2â€¿'i'â€¿'.'â€¿"audioFormat"  â€¿âŸ¨âŸ©
    2â€¿'i'â€¿'.'â€¿"numChannels"  â€¿âŸ¨âŸ©
    4â€¿'i'â€¿'.'â€¿"sampleRate"   â€¿âŸ¨âŸ©
    4â€¿'i'â€¿'w'â€¿"byteRate"     â€¿âŸ¨Ã—Â´Ã·8Ë™,"sampleRate","numChannels","bitsPerSample"âŸ©
    2â€¿'i'â€¿'w'â€¿"blockAlign"   â€¿âŸ¨Ã—Â´Ã·8Ë™,"numChannels","bitsPerSample"âŸ©
    2â€¿'i'â€¿'.'â€¿"bitsPerSample"â€¿âŸ¨âŸ©
    4â€¿'c'â€¿'?'â€¿"subchunk2ID"  â€¿âŸ¨"data"âŸ©
    4â€¿'i'â€¿'.'â€¿"subchunk2Size"â€¿âŸ¨âŸ©
  âŸ©
  def â†© nameâŠ¸âŠâŒ¾(1âŠ¸â†“)âŸ(1<â‰ )Â¨ def

  # Topological order for field definitions
  order â‡ {{ğ•ŠâŸ(l>â—‹â‰ âŠ¢)âŸœ(ğ•©âˆ¾Â·/ğ•¨âŠ¸<)ğ•¨âˆ¨âˆ§Â´âˆ˜âŠâŸœğ•¨Â¨l}âŸœ/0Â¨lâ†ğ•©} 1â†“Â¨def

  # Then fill blank definitions with a self-reference
  def â†© â†•âˆ˜â‰ âŠ¸({âŠ‘â€¿ğ•¨âŸ(0=â‰ )ğ•©}Â¨) def
}

# Return an undoable (â¼) function to convert bytes to PCM data.
_audioConvert â† {
  audioFormatâ€¿bitsPerSample â† ğ•—
  "Bits per sample must be a multiple of 8" ! 0=8|bitsPerSample
  "Bits per sample cannot exceed 64" ! bitsPerSample â‰¤ 64
  l â† bitsPerSampleÃ·8
  _withInv_ â† {F _ğ•£_ G: {ğ•Š:Fğ•© ; ğ•Šâ¼:Gğ•©}}
  {
  1:
    bâ†256
    (+âŸœ(bâŠ¸Ã—)Ëâˆ˜â‰âŒŠâ€¿lâ¥ŠâŠ¢) _withInv_ (â¥Šâˆ˜â‰âˆ˜>b|âŒŠâˆ˜Ã·âŸœbâŸ(â†•l)) -âŸœ@ ;
#;3:floating-point
  ğ•©:
    0 !Ëœ "Unsupported audio format: "âˆ¾â•audioFormat
  }audioFormat
}

# ğ•¨ is audioFormatâ€¿bitsPerSample.
# Force ğ•© to fit in format ğ•¨, emitting approprate warnings.
ForceFormat â† { fâ€¿b ğ•Š pcm:
  Dither â† {
    â€¢OutâŸo.warn_dither "Signal is non-integral; dithering..."
    o.Dither ğ•©
  }
  Clip â† {
    â€¢OutâŸo.warn_clip "Signal out of bounds; clipping..."
    max âŒŠ min âŒˆ ğ•©
  }
  minâ€¿max â† (-â‰-âŸœ1) 2â‹†b-1
  (ClipâŸ(minâŠ¸> âˆ¨â—‹(âˆ¨Â´â¥Š) >âŸœmax) Ditherâˆ˜âŠ£âŸâ‰¢âŸœâŒŠ)âŸ(f=1) pcm
}

DecodeWav â† {
  If â† {ğ•âŸğ•@}Â´
  While â† {ğ•¨{ğ•Šâˆ˜ğ”¾âŸğ”½ğ•©}ğ•©@}Â´
  # Integer from little-endian unsigned bytes
  ToInt â† 256âŠ¸Ã—âŠ¸+ËœÂ´ -âŸœ@

  hdrâ€¿dat â† wh.len +Â´âŠ¸(â†‘ â‰â—‹< â†“) ğ•©

  # Assign field values to field names.
  hdr â†© ('i'=wh.typ) ToIntâˆ˜âŠ¢âŸâŠ£Â¨ wh.len /âŠ¸âŠ” hdr
  â(1â†“âˆ¾"â€¿"âŠ¸âˆ¾Â¨wh.name)âˆ¾"â†hdr"
  # Handle extensible format
  "subchunk1Size is invalid" ! 0â€¿2â€¿24 âˆŠËœ seâ†subchunk1Size-16
  If (se>0)â€¿{ğ•¤
    ! se = 2 + ToInt 2â†‘subchunk2ID
    extâ†@ â‹„ extâ€¿dat â†© se (â†‘ â‰â—‹< â†“) dat
    If (se>2)â€¿{ğ•¤
      If (audioFormat = 65534)â€¿{ğ•¤â‹„ audioFormat â†© ToInt 4â†‘ext }
    }
  }
  # Ignore remaining subchunks
  s â† subchunk2Size
  While {ğ•¤â‹„"data"â‰¢subchunk2ID}â€¿{ğ•¤
    subchunk2IDâ€¿sâ€¿dat â†© (4âŠ¸â†‘ â‰â—‹< ToIntâˆ˜((4+â†•4)âŠ¸âŠ) â‰â—‹< 8âŠ¸â†“) s â†“ dat
    subchunk2Size +â†© s+8
  }
  # Check that fields match their definitions
  e â† hdr â‰¢âŸœ(âŠ‘{ğ•ğ•©âŠhdr}1âŠ¸â†“)Â¨ wh.def
  Msg â† "Values for fields " (âˆ¾âˆ¾âŸœ" "Â¨) "are incorrect"Ë™
  _alert â† {(ğ”½âˆ˜Msg /âŸœ(wh.name))âŸ(âˆ¨Â´) e âˆ§ wh.errâŠ¸âˆŠ}
  !âŸœ0 _alert "e"âˆ¾(se<0)/"?"
  (â€¢Out "Warning: "âˆ¾âŠ¢) _alert "w"

  fmt â† audioFormatâ€¿bitsPerSample
  Cvt â† fmt _audioConvert
  âŸ¨sampleRate, fmt, â‰ âŒŠâ€¿numChannels â¥Š CvtâŠ(âŠ£âŠ˜Cvt subchunk2SizeâŠ¸â†‘) datâŸ©
}

EncodeWav â† { rateâ€¿fmtâ€¿pcm:
  ! 2 â‰¥ =pcm
  pcm â¥ŠâŸœ0âŠ¸â†“Ëœâ†© 2
  dat â† fmt _audioConvertâ¼ fmt ForceFormat â¥Šâ‰pcm
  inameâ€¿ival â† <Ë˜â‰âˆ˜â€¿2â¥ŠâŸ¨
    "sampleRate"   , rate
    "numChannels"  , â‰ pcm
    "subchunk2Size", â‰ dat
    "audioFormat"  , 0âŠ‘fmt
    "bitsPerSample", 1âŠ‘fmt
  âŸ©
  val â† def â† (â¥Šâˆ˜<Â¨ival)âŒ¾((wh.nameâŠiname)âŠ¸âŠ) wh.def

  { val â†© (âŠ‘{ğ•ğ•©âŠval}1âŠ¸â†“)âŒ¾(ğ•©âŠ¸âŠ‘) val }Â¨ wh.order

  hdr â† âˆ¾ (wh.lenÃ—wh.typ='i') 256{@+ğ•—|âŒŠâˆ˜Ã·âŸœğ•—âŸ(â†•ğ•¨)ğ•©}âŸ(>âŸœ0)Â¨ val
  hdr âˆ¾ dat
}

GetWav â† DecodeWavâˆ˜{ o.FBytes ğ•© }
ReadWav  â† { Â¯1âŠ¸âŠ‘âŸ(âŸ¨o.freq,o.fmtâŸ© â‰¡ 2âŠ¸â†‘) GetWav ğ•© }
WriteWav â† { ğ•© o.FBytes EncodeWav(âŸ¨o.freq,o.fmtâŸ©âˆ¾<)âŸ(1â‰¥â‰¡) ğ•¨ }

# Read, setting o.freq and o.fmt as a side effect.
ReadWav_set â† { tâ†GetWav ğ•© â‹„ Set Â¯1â†“t â‹„ Â¯1âŠ‘t }

# Read, resampling to fit current frequency, using options.Resample
ReadWav_coerce â† { ((o.freqâˆ¾Ëœ0âŠ¸âŠ‘) o.Resample Â¯1âŠ¸âŠ‘) GetWav ğ•© }
